# -*- coding: utf-8 -*-
"""ProyectoFinancierasII.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BFc7j9gZV-zKWULYx3CkC2g8_fQc6l1L
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import datetime as dt
import seaborn as sns
import yfinance as yf

#Cargamos las libreria Pypfopt que nos ayudara con nuestro analisis financiero

from pypfopt import risk_models
from pypfopt import plotting
from pypfopt import expected_returns
from pypfopt.efficient_frontier import EfficientFrontier

fecha_inicio = dt.datetime(2020, 6, 1)
fecha_final = dt.datetime(2025, 5, 31)

lista_activos = ['MSFT', 'NVDA', 'AAPL', 'AMZN', 'META', 'AVGO', 'GOOGL', 'TSLA', 'BRK-B', 'GOOG'] #Tomamos las 10 acciones mas influyentes del S&P500
portfolio = yf.download(lista_activos, start=fecha_inicio, end=fecha_final) #Descargamos la informacion de los ultimos 5 años

portfolio = portfolio['Close'].dropna()
#Antes se usaba Adj Close para los calculos pero al parecer las nuevas versiones de la libreria hacen lo necesario para que baste con Close

print(portfolio.head())

portfolio.to_csv('portfolio.csv', index=True) #Convertimos a archivo csv nuestra data descargada
portfolio = pd.read_csv('portfolio.csv', index_col="Date", parse_dates=True) #La cargamos ahora como un dataframe usando pandas

portfolio[portfolio.index >= "2020-06-01"].plot(figsize=(15,10)) #Graficamos el comportamiento de las acciones estos ultimos 5 años

rendimientos_log = np.log(portfolio).diff() #Calculamos los rendimientos logaritmicos
rendimientos_log.dropna(inplace=True)
#rendimientos_log

rendimientos_anuales = rendimientos_log.mean() * 252 #El Rendimiento esperado anual se puede ver como la media de los rendimientos por los 252 dias de un año financiero
print("Rendimiento anual esperado: \n")
print(rendimientos_anuales)

plt.figure(2)
rendimientos_anuales.plot.barh(figsize=(10,6), title='Rendimiento anual esperado de los activos')

mu = expected_returns.mean_historical_return(portfolio, frequency=252, log_returns=True, compounding=False) #Calculamos el rendimiento esperado historico para comparar
print(mu) #Coinciden con lo obtenido calculandolo nosotros mismo

matriz_cov = risk_models.sample_cov(portfolio, frequency=252) #Matriz de Varianza - Covarianza anual
print('Matriz de Varianza - Covarianza')
print(matriz_cov)

riesgo_anual = rendimientos_log.std() * np.sqrt(252) #Riesgo anual que es lo mismo que la desviacion estandar anual
print("Riesgo anual de cada accion: \n")
print(riesgo_anual) #Podemos ver que coincide con la raiz de cada una de las varianzas de la matriz

S = risk_models.CovarianceShrinkage(portfolio).ledoit_wolf() #Matriz de Varianza - Covarianza empirica. La documentacion de la libreria recomienda este metodo para mejores calculos
#S

plt.figure(3, figsize=(8, 6))
sns.heatmap(
  risk_models.cov_to_corr(matriz_cov),
  annot=True, #Muestra los valores de la correlacion
  cmap='viridis',
  fmt=".3f",        # Format the annotation values
  linewidths=.5
)
plt.title('Mapa de calor Matriz de Correlacion')
plt.show()

ef = EfficientFrontier(mu, S)

fig, ax = plt.subplots(figsize= (10,6))
plotting.plot_efficient_frontier(ef, ax=ax, show_assets=True, show_tickers=True)
plt.show()

ef = EfficientFrontier(mu, S)
weights = ef.min_volatility()

cleaned_weights = ef.clean_weights()
print(dict(cleaned_weights))

plotting.plot_weights(cleaned_weights)

ef.portfolio_performance(verbose=True)

n_samples = 10000
w = np.random.dirichlet(np.ones(len(mu)), n_samples)
rets = w.dot(mu)
stds = np.sqrt((w.T * (S @ w.T)).sum(axis=0))
sharpes = rets / stds

print("Retornos del portafolio de muestra:", rets)
print("Volatilidades del portafolio de muestra: \n", stds)

# Graficamos la Frontera Eficiente usando simulacion de Monte Carlo
ef = EfficientFrontier(mu, S)

fig, ax = plt.subplots(figsize= (10,6))
plotting.plot_efficient_frontier(ef, ax=ax, show_assets=False)

# Encontramos y graficamos el portafolio tangente
ef2 = EfficientFrontier(mu, S)
ef2.min_volatility()
ret_tangent, std_tangent, _ = ef2.portfolio_performance()

# Graficamos POrtafolios Aleatorios
ax.scatter(stds, rets, marker=".", c=sharpes, cmap="viridis_r")
ax.scatter(std_tangent, ret_tangent, c='blue', marker='*',s=150, label= 'Min Volatility')

# Formato
ax.set_title("Frontera de Eficiencia con portafolios aleatorios")
ax.legend()
plt.tight_layout()
plt.show()

precios_mercado = yf.download("^GSPC", start=fecha_inicio, end=fecha_final) #Descargamos la informacion del indice S&P500
precios_mercado = precios_mercado['Close'] #Asi tenemos los precios del mercado para calcular su rendimiento esperado

rf = 0.044 #Activo libre de riesgo. Tomamos los bonos del Tesoro de E.E.U.U

r_M = expected_returns.mean_historical_return(precios_mercado, log_returns=True, compounding=False)
print("Rendimiento anual esperado del mercado: %f" %r_M) #Rendimiento anual esperado del mercado

rendimientos_log_mercado = np.log(precios_mercado).diff() #Calculamos los rendimientos logaritmicos del indice S&P500
var_M = rendimientos_log_mercado.var() * 252
print("Varianza anual del mercado: %f" %var_M) #Varianza anual del mercado

sd_M = np.sqrt(var_M)
print("Desviacion estandar del mercado: %f" %sd_M) #Desviacion estandar anual del mercado

sharpe_ratio = (r_M - rf) / sd_M #Calculamos la pendiente del CML que es lo mismo que el ratio de Sharpe
print("\nRatio de Sharpe: %f" %sharpe_ratio)

#mu_CML = rf + sharpe_ratio * sd_Port #Calculamos el rendimiento esperado del CML (Revisar esto)

mu_capm = expected_returns.capm_return(portfolio, risk_free_rate = rf, market_prices=precios_mercado, log_returns=True, compounding=False)
print("Rendimiento Anual esperado por CAPM: \n")
print(mu_capm)

mu_capm.plot.barh(figsize=(10,6), title="Rendimineto anual esperado por CAPM de los activos")

betas = (mu_capm - rf)/(r_M['^GSPC'] - rf) #Para estimar los betas calculados por pyportfolio
print("Betas: \n")
print(betas)

x = [0, 1, 2]
y = [rf, r_M['^GSPC'], rf + 2*(r_M['^GSPC'] - rf)]
plt.plot(x, y)
plt.xlabel('Betas')
plt.ylabel('Rendimientos esperados')
plt.title('Línea de Mercado de Valores (SML)')
plt.show()

alpha = mu - mu_capm
print("Alfas de Jensen: \n")
print(alpha)